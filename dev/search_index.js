var documenterSearchIndex = {"docs":
[{"location":"elements/","page":"Markdown AST elements","title":"Markdown AST elements","text":"CurrentModule = MarkdownAST","category":"page"},{"location":"elements/#Markdown-AST-elements","page":"Markdown AST elements","title":"Markdown AST elements","text":"","category":"section"},{"location":"elements/","page":"Markdown AST elements","title":"Markdown AST elements","text":"Every node in the Markdown abstract syntax tree (AST) is associated with an element[1], providing semantic information to the node (e.g. that the node is a paragraph, or a inline code snippet). In MarkdownAST, each element is an instance of some subtype of AbstractElement, and may (but does not have to) have fields that contain additional information about how to interpret the element (e.g. the language tag of a code block).","category":"page"},{"location":"elements/","page":"Markdown AST elements","title":"Markdown AST elements","text":"AbstractElement","category":"page"},{"location":"elements/#MarkdownAST.AbstractElement","page":"Markdown AST elements","title":"MarkdownAST.AbstractElement","text":"abstract type AbstractElement\n\nA supertype of all Markdown AST element types.\n\nUser-defined elements must not directly inherit this type, but either AbstractBlock or AbstractInline instead.\n\nInterface\n\nBy default, each element is assumed to be a leaf element that can not contain other elements as children. An iscontainer method can be defined to override this.\ncan_contain can be overridden to constrain what elements can be the direct children of another node. By default, inline container elements can contain any inline element and block container elements can contain any block element.\nElements that are implemented as mutable structs should probably implement the equality operator (==), to make sure that two different instances that are semantically the same would be considered equal.\n\n\n\n\n\n","category":"type"},{"location":"elements/","page":"Markdown AST elements","title":"Markdown AST elements","text":"If an element does contain some fields, it is usually a mutable type so that it would be possible to update it.","category":"page"},{"location":"elements/","page":"Markdown AST elements","title":"Markdown AST elements","text":"When the Markdown AST is represented using Nodes, the corresponding elements can be accessed via the .element field.","category":"page"},{"location":"elements/","page":"Markdown AST elements","title":"Markdown AST elements","text":"[1]: This terminology mirrors how each node of the HTML DOM tree is some HTML element.","category":"page"},{"location":"elements/#Block-and-inline-nodes","page":"Markdown AST elements","title":"Block and inline nodes","text":"","category":"section"},{"location":"elements/","page":"Markdown AST elements","title":"Markdown AST elements","text":"In the Markdown AST, the elements can, broadly, be divided into two categories: block and inline elements. The block elements represent the main, top-level structural elements of a document (e.g. paragraphs, headings, block quotes), whereas inline elements represent components of a paragraph (e.g. bold or plain text, inline math or code snippets). In MarkdownAST, every block and inline element is a subtype of AbstractBlock and AbstractInline, respectively.","category":"page"},{"location":"elements/","page":"Markdown AST elements","title":"Markdown AST elements","text":"AbstractBlock\nAbstractInline\nisblock\nisinline","category":"page"},{"location":"elements/#MarkdownAST.AbstractBlock","page":"Markdown AST elements","title":"MarkdownAST.AbstractBlock","text":"abstract type AbstractBlock <: AbstractElement\n\nSupertype of all Markdown AST block types.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.AbstractInline","page":"Markdown AST elements","title":"MarkdownAST.AbstractInline","text":"abstract type AbstractInline <: AbstractElement\n\nSupertype of all Markdown AST inline types.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.isblock","page":"Markdown AST elements","title":"MarkdownAST.isblock","text":"isblock(element::AbstractElement) -> Bool\n\nDetermines if element is a block element (a subtype of AbstractBlock).\n\n\n\n\n\n","category":"function"},{"location":"elements/#MarkdownAST.isinline","page":"Markdown AST elements","title":"MarkdownAST.isinline","text":"isinline(element::AbstractElement) -> Bool\n\nDetermines if element is an inline element (a subtype of AbstractInline).\n\n\n\n\n\n","category":"function"},{"location":"elements/#Constraints-on-children","page":"Markdown AST elements","title":"Constraints on children","text":"","category":"section"},{"location":"elements/","page":"Markdown AST elements","title":"Markdown AST elements","text":"As the AST is a tree, nodes (or elements) can have other nodes or elements as children. However, it does not generally make sense for a node to have arbitrary nodes as children. For this purpose, there are methods to ensure","category":"page"},{"location":"elements/","page":"Markdown AST elements","title":"Markdown AST elements","text":"First, for some elements it does not make sense for them to have any children at all (i.e. they will always be leaf nodes). Whether or not an node is a container node (i.e. whether or not it can have other elements as children) is determined by the iscontainer function.","category":"page"},{"location":"elements/","page":"Markdown AST elements","title":"Markdown AST elements","text":"iscontainer","category":"page"},{"location":"elements/#MarkdownAST.iscontainer","page":"Markdown AST elements","title":"MarkdownAST.iscontainer","text":"iscontainer(::T) where {T <: AbstractElement} -> Bool\n\nDetermines if the particular Markdown element is a container, meaning that is can contain child nodes. Adding child nodes to non-container (leaf) nodes is prohibited.\n\nBy default, each user-defined element is assumed to be a leaf node, and each container node should override this method.\n\n\n\n\n\n","category":"function"},{"location":"elements/","page":"Markdown AST elements","title":"Markdown AST elements","text":"However, a more fine-grained control over the allowed child nodes is often necessary. For example, while a paragraph can have child nodes, it does not make sense for a paragraph to have another paragraph as a child node, and in fact it should only have inline nodes as children. Such relationships are defined by the can_contain function (e.g. for a Paragraph it only returns true if the child element is an AbstractInline).","category":"page"},{"location":"elements/","page":"Markdown AST elements","title":"Markdown AST elements","text":"can_contain","category":"page"},{"location":"elements/#MarkdownAST.can_contain","page":"Markdown AST elements","title":"MarkdownAST.can_contain","text":"can_contain(parent::AbstractElement, child::AbstractElement) -> Bool\n\nDetermines if the child element can be a direct child of the parent element.\n\nThis is used to constrain the types of valid children for some elements, such as for the elements that are only allowed to have inline child elements or to make sure that Lists only contain Items.\n\nIf the parent element is a leaf node (iscontainer(parent) === false)\n\nExtended help\n\nWhen extending can_contain for custom abstract classes Markdown elements, similar to the AbstractBlock or AbstractInline elements classes, the second argument to can_contain should always be constrained exactly to ::AbstractElement, in order to avoid method ambiguities. I.e. for some abstract type AbstractT  <: AbstractElement, the method should be defined as\n\ncan_contain(parent::AbstractT, child::AbstractElement) = ...\n\nFor concrete parent types T, where the first argument is constrained as parent::T it should then be fine to take advantage of multiple dispatch when implementing can_contain.\n\n\n\n\n\n","category":"function"},{"location":"elements/","page":"Markdown AST elements","title":"Markdown AST elements","text":"Usually, the constraint is whether a container node can contain only block elements or only inline elements.","category":"page"},{"location":"elements/","page":"Markdown AST elements","title":"Markdown AST elements","text":"note: Note\nSometimes it might be desireable to have even more sophisticated constraints on the elements (e.g. perhaps two elements are not allowed to directly follow each other as children of another node). However, it is not practical to over-complicate the APIs here, and simply restricting the child elements of another element seems to strike a good balance.Instead, in cases where it becomes possible to construct trees that have questionable semantics due to a weird structure that can not be restricted with can_contain, the elements should carefully document how to interpret such problematic trees (e.g. how to interpret a table that has no rows and columns).","category":"page"},{"location":"elements/#CommonMark-elements","page":"Markdown AST elements","title":"CommonMark elements","text":"","category":"section"},{"location":"elements/","page":"Markdown AST elements","title":"Markdown AST elements","text":"The CommonMark specification specifies a set of block and inline nodes that can be used to represent Markdown documents.","category":"page"},{"location":"elements/","page":"Markdown AST elements","title":"Markdown AST elements","text":"Backslash\nBlockQuote\nCode\nCodeBlock\nEmph\nHTMLBlock\nHTMLInline\nHeading\nImage\nItem\nLineBreak\nLink\nList\nParagraph\nSoftBreak\nStrong\nText\nThematicBreak","category":"page"},{"location":"elements/#MarkdownAST.Backslash","page":"Markdown AST elements","title":"MarkdownAST.Backslash","text":"struct Backslash <: AbstractInline\n\nRepresents a backslash character \\.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.BlockQuote","page":"Markdown AST elements","title":"MarkdownAST.BlockQuote","text":"struct BlockQuote <: AbstractBlock\n\nA singleton container element representing a block quote. It must contain other block elements as children.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.Code","page":"Markdown AST elements","title":"MarkdownAST.Code","text":"mutable struct Code <: AbstractInline\n\nInline element representing an inline code span.\n\nFields\n\n.code :: String: raw code\n\nConstructors\n\nCode(code::AbstractString)\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.CodeBlock","page":"Markdown AST elements","title":"MarkdownAST.CodeBlock","text":"mutable struct CodeBlock <: AbstractBlock\n\nA leaf block representing a code block.\n\nFields\n\n.info :: String: code block info string (e.g. the programming language label)\n.code :: String: code content of the block\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.Emph","page":"Markdown AST elements","title":"MarkdownAST.Emph","text":"struct Emph <: AbstractInline\n\nInline singleton element for emphasis (e.g. italic) styling.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.HTMLBlock","page":"Markdown AST elements","title":"MarkdownAST.HTMLBlock","text":"mutable struct HTMLBlock <: AbstractBlock\n\nA leaf block representing raw HTML.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.HTMLInline","page":"Markdown AST elements","title":"MarkdownAST.HTMLInline","text":"mutable struct HTMLInline <: AbstractInline\n\nInline leaf element representing raw inline HTML.\n\nFields\n\n.html :: String: inline raw HTML\n\nConstructors\n\nHTMLInline(html::AbstractString)\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.Heading","page":"Markdown AST elements","title":"MarkdownAST.Heading","text":"mutable struct Heading <: AbstractBlock\n\nRepresents a heading of a specific level. Can only contain inline elements as children.\n\nFields\n\n.level :: Int: the level of the heading, must be between 1 and 6.\n\nConstructors\n\nHeading(level :: Integer)\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.Image","page":"Markdown AST elements","title":"MarkdownAST.Image","text":"mutable struct Image <: AbstractInline\n\nInline element representing a link to an image. Can contain other inline nodes that will represent the image description.\n\nFields\n\n.destination :: String: destination URL\n.title :: String: title attribute of the link\n\nConstructors\n\nLink(destination::AbstractString, title::AbstractString)\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.Item","page":"Markdown AST elements","title":"MarkdownAST.Item","text":"struct Item <: AbstractBlock\n\nSingleton container representing the items of a List.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.LineBreak","page":"Markdown AST elements","title":"MarkdownAST.LineBreak","text":"struct LineBreak <: AbstractInline\n\nRepresents a hard line break in a sequence of inline nodes that should lead to a newline when rendered.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.Link","page":"Markdown AST elements","title":"MarkdownAST.Link","text":"mutable struct Link <: AbstractInline\n\nInline element representing a link. Can contain other inline nodes, but should not contain other Links.\n\nFields\n\n.destination :: String: destination URL\n.title :: String: title attribute of the link\n\nConstructors\n\nLink(destination::AbstractString, title::AbstractString)\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.List","page":"Markdown AST elements","title":"MarkdownAST.List","text":"mutable struct List <: AbstractBlock\n\nRepresents a Markdown list. The children of a List should only be Items, representing individual list items.\n\nFields\n\n.type :: Symbol: determines if this is an ordered (:ordered) or an unordered (:bullet) list.\n.tight :: Bool: determines if the list should be rendered tight or loose.\n\nConstructors\n\njulia List(type :: Symbol, tight :: Bool)`\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.Paragraph","page":"Markdown AST elements","title":"MarkdownAST.Paragraph","text":"struct Paragraph <: AbstractBlock\n\nSingleton container representing a paragraph, containing only inline nodes.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.SoftBreak","page":"Markdown AST elements","title":"MarkdownAST.SoftBreak","text":"struct SoftBreak <: AbstractInline\n\nRepresents a soft break which can be rendered as a space instead.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.Strong","page":"Markdown AST elements","title":"MarkdownAST.Strong","text":"struct Strong <: AbstractInline\n\nInline singleton element for strong (e.g. bold) styling.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.Text","page":"Markdown AST elements","title":"MarkdownAST.Text","text":"mutable struct Text <: AbstractInline\n\nInline leaf element representing a simply a span of text.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.ThematicBreak","page":"Markdown AST elements","title":"MarkdownAST.ThematicBreak","text":"struct ThematicBreak <: AbstractBlock\n\nA singleton leaf element representing a thematic break (often rendered as a horizontal rule).\n\n\n\n\n\n","category":"type"},{"location":"elements/#Julia-extension-elements","page":"Markdown AST elements","title":"Julia extension elements","text":"","category":"section"},{"location":"elements/","page":"Markdown AST elements","title":"Markdown AST elements","text":"The Julia version of Markdown contains additional elements that do not exists in the CommonMark specification (such as tables or math). However, as MarkdownAST is meant to be interoperable with the Markdown standard library parser, it also supports additional elements to accurately represent the Julia Flavored Markdown documents.","category":"page"},{"location":"elements/","page":"Markdown AST elements","title":"Markdown AST elements","text":"Admonition\nDisplayMath\nFootnoteDefinition\nFootnoteLink\nInlineMath\nJuliaValue\nTable\nTableBody\nTableCell\nTableHeader\nTableRow","category":"page"},{"location":"elements/#MarkdownAST.Admonition","page":"Markdown AST elements","title":"MarkdownAST.Admonition","text":"mutable struct Admonition <: AbstractBlock\n\nA container block representing an admonition. Can contain other block elements as children.\n\nFields\n\n.category :: String: admonition category\n.title :: String: admonition title\n\nConstructors\n\nAdmonition(category :: AbstractString, title :: AbstractString)\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.DisplayMath","page":"Markdown AST elements","title":"MarkdownAST.DisplayMath","text":"mutable struct DisplayMath <: AbstractBlock\n\nLeaf block representing a mathematical display equation.\n\nFields\n\n.math :: String: TeX code of the display equation\n\nConstructors\n\nDisplayMath(math :: AbstractString)\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.FootnoteDefinition","page":"Markdown AST elements","title":"MarkdownAST.FootnoteDefinition","text":"mutable struct FootnoteDefinition <: AbstractBlock\n\nContainer block representing the definition of a footnote, containing the definitions of the footnote as children.\n\nFields\n\n.id :: String: label of the footnote\n\nConstructors\n\nFootnoteDefinition(id :: AbstractString)\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.FootnoteLink","page":"Markdown AST elements","title":"MarkdownAST.FootnoteLink","text":"mutable struct FootnoteLink <: AbstractInline\n\nInline leaf element representing a link to a footnote.\n\nFields\n\n.id :: String: label of the footnote\n\nConstructors\n\nFootnoteLink(id :: AbstractString)\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.InlineMath","page":"Markdown AST elements","title":"MarkdownAST.InlineMath","text":"mutable struct InlineMath <: AbstractInline\n\nLeaf inline element representing an inline mathematical expression.\n\nFields\n\n.math :: String: TeX code for the inline equation\n\nConstructors\n\nInlineMath(math::String)\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.JuliaValue","page":"Markdown AST elements","title":"MarkdownAST.JuliaValue","text":"struct JuliaValue <: AbstractInline\n\nInline leaf element for interpolation of Julia expressions and their evaluated values. Two JuliaValue objects are considered equal if the Julia objects they refer to are equal (even if they originate from different expressions).\n\nFields\n\n.ex :: Any: contains the original Julia expression (e.g. Expr, Symbol, or some literal value)\n.ref :: Any: stores the Julia object the expression evaluates to\n\nConstructors\n\nJuliaValue(ex, ref = nothing)\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.Table","page":"Markdown AST elements","title":"MarkdownAST.Table","text":"mutable struct Table <: TableComponent\n\nContainer block representing a table, an extension of the CommonMark spec, and should be interpreted as a rectangular grid of cells with a fixed number of rows and columns.\n\nA Table node can only contain either TableHeader or TableBody nodes as children.\nTableHeader and TableBody can only contain TableRows as children. A TableHeader should contain only a single TableRow, and any additional ones should be ignored.\nEach TableRow contains only TableCells as children. The row with the largest number of cells determines the width (number of columns) of the table.\n\nSince we can not constrain e.g. the number of children or in what order child nodes can appear in a Markdown tree, it is possible to construct tables that can be difficult to interpret. The following rules should be followed when interpreting tables:\n\nThe decendants of a Table node should be exactly be a single TableHeader followed by a TableBody.\nIf the first child is a TableBody, the header row is assumed to be a list of empty cells.\nThe rows from any nodes following the first TableBody are interpreted as additional table body rows, even if they are contained in a TableHeader.\nA Table with no children is interpreted as a table with a single empty header cell.\nA TableHeader that is the first child of a Table should only contain one TableRow.\nIf a TableHeader that is the first child of a Table contains additional rows, the additional rows are interpreted to be body rows.\nIf a TableHeader that is the first child of a Table is empty, it is assumed to represent a header row with empty cells.\nEach TableRow of a table should contain the same number of TableCell.\nAny row that has fewer cells than the longest row should be interpreted as if it is padded with additional empty cells.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.TableBody","page":"Markdown AST elements","title":"MarkdownAST.TableBody","text":"struct TableBody <: TableComponent\n\nRepresents the body of a Markdown table and should only occur as the second child of a Table node. See Table for information on how to handle other circumstances.\n\nIt can only contain TableRow elements.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.TableCell","page":"Markdown AST elements","title":"MarkdownAST.TableCell","text":"mutable struct TableCell <: TableComponent\n\nRepresents a single cell in a Markdown table. Can contain inline nodes.\n\nalign :: Symbol: declares the alignment of a cell (can be :left, :right, or :center), and should match the .spec field of the ancestor Table\nheader :: Bool: true if the cell is part of a header row, and should only be true if the cell belongs to a row that is the first\ncolumn :: Int: the column index of the cell, which should match its position in the Markdown tree\n\nIt is possible that the fields of TableCell are inconsistent with the real structure of the Markdown tree, in which case the structure or the .spec field should take precedence when interpreting the elements.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.TableHeader","page":"Markdown AST elements","title":"MarkdownAST.TableHeader","text":"struct TableHeader <: TableComponent\n\nRepresents the header portion of a Markdown table and should only occur as the first child of a Table node and should only contain a single TableRow as a child. See Table for information on how to handle other circumstances.\n\nIt can only contain TableRow elements.\n\n\n\n\n\n","category":"type"},{"location":"elements/#MarkdownAST.TableRow","page":"Markdown AST elements","title":"MarkdownAST.TableRow","text":"struct TableRow <: TableComponent\n\nRepresents a row of a Markdown table. Can only contain TableCells as children.\n\n\n\n\n\n","category":"type"},{"location":"elements/#Other-elements","page":"Markdown AST elements","title":"Other elements","text":"","category":"section"},{"location":"elements/","page":"Markdown AST elements","title":"Markdown AST elements","text":"Document is the root element of a Markdown document.","category":"page"},{"location":"elements/","page":"Markdown AST elements","title":"Markdown AST elements","text":"Document","category":"page"},{"location":"elements/#MarkdownAST.Document","page":"Markdown AST elements","title":"MarkdownAST.Document","text":"struct Document <: AbstractBlock\n\nSingleton top-level element of a Markdown document.\n\n\n\n\n\n","category":"type"},{"location":"elements/#Index","page":"Markdown AST elements","title":"Index","text":"","category":"section"},{"location":"elements/","page":"Markdown AST elements","title":"Markdown AST elements","text":"Pages = [\"elements.md\"]","category":"page"},{"location":"astmacro/#Constructing-trees","page":"Constructing trees","title":"Constructing trees","text":"","category":"section"},{"location":"astmacro/","page":"Constructing trees","title":"Constructing trees","text":"The @ast macro can be used to construct complex trees with relatively little effort, without having to construct and push all the Node instances yourself.","category":"page"},{"location":"astmacro/","page":"Constructing trees","title":"Constructing trees","text":"MarkdownAST.@ast","category":"page"},{"location":"astmacro/#MarkdownAST.@ast","page":"Constructing trees","title":"MarkdownAST.@ast","text":"@ast markdown-node-expression\n\nA macro that implements a simple domain specific language to easily and explicitly construct a Markdown AST.\n\nThe markdown-node-expression must be either:\n\nA Markdown element (i.e. some AbstractElement object), such as a constructor call (e.g. Paragraph()), function call returning an element, or a variable pointing to an element.\nA do-block, with the function call part being an element (as above), and the contents of the do-block a sequence of other node expressions, i.e.\nelement do\n    child-node-expression-1\n    child-node-expression-2\n    ...\nend\n\nIn practice, a simple example might look something like\n\n@ast Document() do\n    Heading(1) do\n        \"Top-level heading\"\n    end\n    Paragraph() do\n        \"Some paragraph text\"\n    end\nend\n\nStrings are interpreted as Text(s) elements.\n\n\n\n\n\n","category":"macro"},{"location":"iteration/#Iteration-over-trees","page":"Iteration over trees","title":"Iteration over trees","text":"","category":"section"},{"location":"iteration/","page":"Iteration over trees","title":"Iteration over trees","text":"The Node type implements the AbstractTrees interface which provides various general tree-iteration algorithms.","category":"page"},{"location":"iteration/","page":"Iteration over trees","title":"Iteration over trees","text":"Using the following MarkdownAST tree as an example:","category":"page"},{"location":"iteration/","page":"Iteration over trees","title":"Iteration over trees","text":"using MarkdownAST: @ast, Document, Heading, Paragraph, Strong, CodeBlock","category":"page"},{"location":"iteration/","page":"Iteration over trees","title":"Iteration over trees","text":"md = @ast Document() do\n    Heading(1) do; \"Iteration example\"; end\n    Paragraph() do\n        \"MarkdownAST trees can be iterated over with \"\n        Strong() do; \"AbstractTrees\"; end\n        \".\"\n    end\n    Paragraph() do; \"The use it, load the package with\"; end\n    CodeBlock(\"julia\", \"using AbstractTrees\")\nend\nnothing # hide","category":"page"},{"location":"iteration/","page":"Iteration over trees","title":"Iteration over trees","text":"The different AbstractTrees iterators, such as PostOrderDFS, PreOrderDFS, or Leaves, can be used to construct iterators from the md variable (which is an instance of Node). Each algorithm provides a way to iterate through the trees in a different way, as can be seen in the following examples:","category":"page"},{"location":"iteration/","page":"Iteration over trees","title":"Iteration over trees","text":"using AbstractTrees\nfor node in PostOrderDFS(md)\n    println(node.element)\nend","category":"page"},{"location":"iteration/","page":"Iteration over trees","title":"Iteration over trees","text":"for node in PreOrderDFS(md)\n    println(node.element)\nend","category":"page"},{"location":"iteration/","page":"Iteration over trees","title":"Iteration over trees","text":"using AbstractTrees\nfor node in Leaves(md)\n    println(node.element)\nend","category":"page"},{"location":"stdlib/","page":"Conversion to/from Markdown","title":"Conversion to/from Markdown","text":"CurrentModule = MarkdownAST","category":"page"},{"location":"stdlib/#Conversion-to-and-from-Markdown-standard-library","page":"Conversion to/from Markdown","title":"Conversion to and from Markdown standard library","text":"","category":"section"},{"location":"stdlib/","page":"Conversion to/from Markdown","title":"Conversion to/from Markdown","text":"The Markdown standard library in Julia provides an alternative representation of the Markdown AST. In particular, the parser and AST there is internally used by Julia for docstrings, and is also used by some of the tooling in the Julia ecosystem that deals with Markdown.","category":"page"},{"location":"stdlib/","page":"Conversion to/from Markdown","title":"Conversion to/from Markdown","text":"MarkdownAST supports bi-directional conversion between the two AST representations via the convert function. The conversion, however, is not perfect since there are differences in what and how the two libraries represent the Markdown AST.","category":"page"},{"location":"stdlib/#Conversion-from-standard-library-representation","page":"Conversion to/from Markdown","title":"Conversion from standard library representation","text":"","category":"section"},{"location":"stdlib/","page":"Conversion to/from Markdown","title":"Conversion to/from Markdown","text":"Any AST that is produced by the Markdown standard library parser should parse into MarkdownAST AST. However, as the data structures for the elements in Markdown are pretty loose in what they allow, user-crafted Markdown ASTs may error if it does not exactly follow the conventions of the Markdown parser.","category":"page"},{"location":"stdlib/","page":"Conversion to/from Markdown","title":"Conversion to/from Markdown","text":"Base.convert(::Type{Node}, md::Markdown.MD)","category":"page"},{"location":"stdlib/#Base.convert-Tuple{Type{MarkdownAST.Node}, Markdown.MD}","page":"Conversion to/from Markdown","title":"Base.convert","text":"convert(::Type{Node}, md::Markdown.MD) -> Node\nconvert(::Type{Node{M}}, md::Markdown.MD, meta=M) where M -> Node{M}\n\nConverts a standard library Markdown AST into MarkdownAST representation.\n\nNote that it is not possible to convert subtrees, as only MD objects can be converted. The result will be a tree with Document as the root element.\n\nWhen the type argument passed is Node, the resulting tree will be constructed of objects of the default node type Node{Nothing}. However, it is also possible to convert into MarkdownAST trees that have custom metadata field of type M, in which case the M type must have a zero-argument constructor available, which will be called whenever a new Node object gets constructed.\n\nIt is also possible to use a custom function to construct the .meta objects via the `meta argument, which must be a callable object with a zero-argument method, and that then gets called every time a new node is constructed.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/","page":"Conversion to/from Markdown","title":"Conversion to/from Markdown","text":"Due to the differences between the Markdown representations, the following things should be kept in mind when converting from the standard library AST into MarkdownAST representation:","category":"page"},{"location":"stdlib/","page":"Conversion to/from Markdown","title":"Conversion to/from Markdown","text":"The standard library parser does not have a dedicated type for representing backslashes, and instead stores them as separate single-character text nodes containing a backslash (i.e. \"\\\\\").\nSoft line breaks are ignored in the standard library parser and represented with a space instead.\nStrings (or Markdown elements) interpolated into the standard library Markdown (e.g. in docstrings or with the @md_str macro) are indistinguishable from text (or corresponding Markdown) nodes in the standard library AST, and therefore will not be converted into JuliaValues.\nThe standard library allows for block-level interpolation. These get converted into inline JuliaValues wrapped in a Paragraph element.\nIn case the standard library AST contains any inline nodes in block context (e.g. as children for Markdown.MD), the get wrapped in a Paragraph element too.\nWhen converting a Markdown.Table, the resulting table will be normalized, such as adding empty cells to rows, to make sure that all rows have the same number of cells.\nFor links and images, the .title attribute is set to an empty string, since the standard library AST does not support parsing titles.","category":"page"},{"location":"stdlib/#Conversion-to-standard-library-representation","page":"Conversion to/from Markdown","title":"Conversion to standard library representation","text":"","category":"section"},{"location":"stdlib/","page":"Conversion to/from Markdown","title":"Conversion to/from Markdown","text":"Any AST that contains only the native MarkdownAST elements can be converted into the standard library representation. The conversion of user-defined elements, however, is not supported and will lead to an error.","category":"page"},{"location":"stdlib/","page":"Conversion to/from Markdown","title":"Conversion to/from Markdown","text":"Base.convert(::Type{Markdown.MD}, node::Node)","category":"page"},{"location":"stdlib/#Base.convert-Tuple{Type{Markdown.MD}, MarkdownAST.Node}","page":"Conversion to/from Markdown","title":"Base.convert","text":"convert(::Type{Markdown.MD}, node::Node) -> Markdown.MD\n\nConverts a MarkdownAST representation of a Markdown document into the Markdown standard library representation.\n\nNote that the root node node must a Document element.\n\n\n\n\n\n","category":"method"},{"location":"stdlib/","page":"Conversion to/from Markdown","title":"Conversion to/from Markdown","text":"Due to the differences between the Markdown representations, the following things should be kept in mind when converting from the MarkdownAST representation into the standard library AST:","category":"page"},{"location":"stdlib/","page":"Conversion to/from Markdown","title":"Conversion to/from Markdown","text":"The value from a JuliaValue element (i.e. .ref) gets stored directly in the AST (just like variable interpolation with docstrings and the @md_str macro). This means that, for example, an interpolated string or Markdown element would become a valid AST element, losing the information that it used to be interpolated.\nThe expression information in a JuliaValue element (i.e. the .ex field) gets discarded.\nThe .title attribute of Link and Image elements gets discarded.\nThe standard library does not support storing the child nodes of Image elements (i.e. \"alt text\", ![alt text]()) as AST, and it is instead reduced to a string with the help of the Markdown.plain function.\nThe standard library AST does not have dedicated elements for SoftBreak and Backslash, and these get converted into strings (i.e. text elements) instead.","category":"page"},{"location":"stdlib/#Index","page":"Conversion to/from Markdown","title":"Index","text":"","category":"section"},{"location":"stdlib/","page":"Conversion to/from Markdown","title":"Conversion to/from Markdown","text":"Pages = [\"stdlib.md\"]","category":"page"},{"location":"node/","page":"Tree node interface","title":"Tree node interface","text":"CurrentModule = MarkdownAST","category":"page"},{"location":"node/#Tree-node-interface","page":"Tree node interface","title":"Tree node interface","text":"","category":"section"},{"location":"node/","page":"Tree node interface","title":"Tree node interface","text":"The Markdown abstract syntax tree (AST) is a tree of Markdown elements. In order to avoid type instabilities when performing basic operations on a tree, such as traversin it, it is implemented by linking together instances of the Node type. Each Node instance functions as a container for some AbstractElement.","category":"page"},{"location":"node/","page":"Tree node interface","title":"Tree node interface","text":"The Node type has various properties that can be used to access information about the structure of the tree, but it is generally not possible to set them directly. Changing the structure of a tree (e.g. to adding child nodes), should be done with the help of the various functions and methods to MarkdownAST provides for mutating the tree.","category":"page"},{"location":"node/","page":"Tree node interface","title":"Tree node interface","text":"Node\nBase.:(==)(::Node{T}, ::Node{T}) where T","category":"page"},{"location":"node/#MarkdownAST.Node","page":"Tree node interface","title":"MarkdownAST.Node","text":"mutable struct Node{M}\n\nImplements a linked list type representation of a Markdown abstract syntax tree, where each node contains pointers to the children and parent nodes, to make it possible to easily traverse the whole tree in any direction. Each node also contains an \"element\", which is an instance of some AbstractElement subtype, and can be accessed via the .element property. The element object contains the semantic information about the node (e.g. wheter it is a list or a paragraph).\n\nOptionally, each node can also store additional meta information, which will be an object of type M (see also the .meta property). By default, the node does not contain any extra meta information and M = Nothing.\n\nConstructors\n\nNode(element :: AbstractElement)\n\nConstructs a simple standalone node (not part of any tree) without any additional metadata (M = Nothing) containing the Markdown AST element c.\n\nNode{M}(element :: AbstractElement, meta :: M)\n\nConstructs a simple standalone node (not part of any tree) with the meta information meta, containing the Markdown AST element c.\n\nExtended help\n\nThere are various properties that can be used to access the details of a node. Many of them can not be set directly though, as that could lead to an inconsistent tree. Similarly, the underlying fields of the struct should not be accessed directly.\n\n.meta :: M: can be used to access or set the extra meta information of the node.\n.element :: T where {T <: AbstractElement}: can be used to access or set the element corresponding to the node\n.next :: Union{Node{M},Nothing}: access the next child node after this one, with the value set to nothing if there is no next child\n.previous :: Union{Node{M},Nothing}: access the previous child node before this one, with the value set to nothing if there is no such node\n.parent :: Union{Node{M},Nothing}: access the parent node of this node, with the value set to nothing if the node does not have a parent\n.children: an iterable object that can be used to acces and modify the children of the node\n\nThe .children field is implemented with a wrapper type that implemements the iteration protocol. However, the exact type information etc. is an implementation detail, and one should only rely on the following documented APIs:\n\nThe following methods are implemented for .children: length, eltype, first, last, isempty\nAppending or prepending new children to a parent node can be done with the push! and pushfirst! methods\n\nOther ways to work with child nodes that do not directly reference .children are:\n\nTo add new children between others, the insert_after!, insert_before! functions can be used to insert new children relative to a reference child node.\nTo remove a child from a node, the unlink! function can be used on the corresponding child node.\n\nIn addition, there are other functions and methods that can be used to work with nodes and trees:\n\nQuerying information about the node: haschildren\nRemoving a node from a tree: unlink!\nTwo trees can be compared with the == operator\n\n\n\n\n\n","category":"type"},{"location":"node/#Base.:==-Union{Tuple{T}, Tuple{MarkdownAST.Node{T}, MarkdownAST.Node{T}}} where T","page":"Tree node interface","title":"Base.:==","text":"==(x::Node, y::Node) -> Bool\n\nDetermines if two trees are equal by recursively walking through the whole tree (if need be) and comparing each node. Parent nodes are ignored when comparing for equality (so that it would be possible to compare subtrees). If the metadata type does not match, the two trees are not considered equal.\n\n\n\n\n\n","category":"method"},{"location":"node/#Accessing-child-nodes","page":"Tree node interface","title":"Accessing child nodes","text":"","category":"section"},{"location":"node/","page":"Tree node interface","title":"Tree node interface","text":"Internally, to store the children, a node simply stores the reference to the first and the last child node, and each child stores the references to the next and previous child. The .children property is implemented simply as a lazy iterator that traverses the linked list. As such, some operations, such as determining the number of children a node has with length, can have unexpected O(n) complexity.","category":"page"},{"location":"node/","page":"Tree node interface","title":"Tree node interface","text":"haschildren\nBase.eltype(::Type{NodeChildren{T}}) where T\nBase.length(::NodeChildren)\nBase.isempty(::NodeChildren)\n#Base.first(::NodeChildren{T}) where T\n#Base.last(::NodeChildren{T}) where T","category":"page"},{"location":"node/#MarkdownAST.haschildren","page":"Tree node interface","title":"MarkdownAST.haschildren","text":"haschildren(node::Node) -> Bool\n\nReturns true if node has any children nodes and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"node/#Base.eltype-Union{Tuple{Type{MarkdownAST.NodeChildren{T}}}, Tuple{T}} where T","page":"Tree node interface","title":"Base.eltype","text":"eltype(node.children) = Node{M}\n\nReturns the exact Node type of the tree, corresponding to the type of the elements of the .children iterator.\n\n\n\n\n\n","category":"method"},{"location":"node/#Base.length-Tuple{MarkdownAST.NodeChildren}","page":"Tree node interface","title":"Base.length","text":"length(node.children) -> Int\n\nReturns the number of children of node :: Node.\n\nAs the children are stored as a linked list, this method has O(n) complexity. As such, to check there are any children at all, it is generally preferable to use isempty.\n\n\n\n\n\n","category":"method"},{"location":"node/#Base.isempty-Tuple{MarkdownAST.NodeChildren}","page":"Tree node interface","title":"Base.isempty","text":"isemtpy(node.children) -> Bool\n\nCan be called on the .children field of a node :: Node to determine whether or not the node has any child nodes.\n\n\n\n\n\n","category":"method"},{"location":"node/","page":"Tree node interface","title":"Tree node interface","text":"Modules = [MarkdownAST]\nFilter = t -> t in [Base.first, Base.last]","category":"page"},{"location":"node/#Base.first-Union{Tuple{MarkdownAST.NodeChildren{T}}, Tuple{T}} where T","page":"Tree node interface","title":"Base.first","text":"first(node.children) -> Node\n\nReturns the first child of the node :: Node, or throws an error if the node has no children.\n\n\n\n\n\n","category":"method"},{"location":"node/#Base.last-Union{Tuple{MarkdownAST.NodeChildren{T}}, Tuple{T}} where T","page":"Tree node interface","title":"Base.last","text":"last(node.children) -> Node\n\nReturns the last child of the node :: Node, or throws an error if the node has no children.\n\n\n\n\n\n","category":"method"},{"location":"node/#Mutating-the-tree","page":"Tree node interface","title":"Mutating the tree","text":"","category":"section"},{"location":"node/","page":"Tree node interface","title":"Tree node interface","text":"The following functions and methods can be used to mutate the Markdown AST trees represented using Node objects. When using these methods, the consistency of the tree is preserved (i.e. the references between the affected nodes are correctly updated). Changing the structure of the tree in any other way should generally be avoided, since the code that operates on trees generally assumes a consistent tree, and will likely error or behave in unexpected ways on inconsistent trees.","category":"page"},{"location":"node/","page":"Tree node interface","title":"Tree node interface","text":"warning: Mutating the tree while traversing\nMutating the structure of the tree while traversing it with some iterator (e.g. .children or one of the AbstractTrees iterators) can lead to unexpected behavior and should generally be avoided. Updating the .element of a node, on the other hand, is fine.","category":"page"},{"location":"node/","page":"Tree node interface","title":"Tree node interface","text":"unlink!\ninsert_before!\ninsert_after!\nBase.push!(::NodeChildren{T}, ::T) where {T <: Node}\nBase.pushfirst!(::NodeChildren{T}, ::T) where {T <: Node}","category":"page"},{"location":"node/#MarkdownAST.unlink!","page":"Tree node interface","title":"MarkdownAST.unlink!","text":"unlink!(node::Node) -> Node\n\nIsolates and removes the node from the tree by removing all of its links to its neighboring nodes. Returns the updated node, which is now a single, isolate root node.\n\n\n\n\n\n","category":"function"},{"location":"node/#MarkdownAST.insert_before!","page":"Tree node interface","title":"MarkdownAST.insert_before!","text":"insert_before!(node::Node, sibling::Node) -> Node\n\nInserts a new child node sibling as the child right before node. node must not be a root node. If sibling is part of another tree, then it is unlinked from that tree first (see unlink!). Returns the original reference node.\n\n\n\n\n\n","category":"function"},{"location":"node/#MarkdownAST.insert_after!","page":"Tree node interface","title":"MarkdownAST.insert_after!","text":"insert_after!(node::Node, sibling::Node) -> Node\n\nInserts a new child node sibling as the next child after node. node must not be a root node. If sibling is part of another tree, then it is unlinked from that tree first (see unlink!). Returns the original reference node.\n\n\n\n\n\n","category":"function"},{"location":"node/#Base.push!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, T}} where T<:MarkdownAST.Node","page":"Tree node interface","title":"Base.push!","text":"Base.push!(node.children, child::Node) -> Node\n\nAdds child as the last child node of node :: Node. If child is part of another tree, then it is unlinked from that tree first (see unlink!). Returns the iterator over children.\n\n\n\n\n\n","category":"method"},{"location":"node/#Base.pushfirst!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, T}} where T<:MarkdownAST.Node","page":"Tree node interface","title":"Base.pushfirst!","text":"Base.pushfirst!(node.children, child::Node) -> Node\n\nAdds child as the first child node of node :: Node. If child is part of another tree, then it is unlinked from that tree first (see unlink!). Returns the iterator over children.\n\n\n\n\n\n","category":"method"},{"location":"node/","page":"Tree node interface","title":"Tree node interface","text":"note: Mutating the .children property\nThe choice to apparently mutate the .children property when adding child nodes is purely syntactic, and in reality the operation affects the parent Node object. Internally the .children iterator is simply a thin wrapper around the parent node.","category":"page"},{"location":"node/#Index","page":"Tree node interface","title":"Index","text":"","category":"section"},{"location":"node/","page":"Tree node interface","title":"Tree node interface","text":"Pages = [\"node.md\"]","category":"page"},{"location":"#MarkdownAST","page":"Introduction","title":"MarkdownAST","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The structure of a Markdown file can be represented as an abstract syntax tree. The MarkdownAST package defines a Julia interface for representing such trees to facilitate the interoperability between different packages that deal with Markdown documents in different ways.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"While the primary goal is to represent Markdown documents, the tree structure, implemented by the Node type and the AbstractElement subtypes, is intentionally generic and can also be used to represent more general documents.","category":"page"}]
}
