<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tree node interface · MarkdownAST</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MarkdownAST</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../elements/">Markdown AST elements</a></li><li class="is-active"><a class="tocitem" href>Tree node interface</a><ul class="internal"><li><a class="tocitem" href="#Accessing-child-nodes"><span>Accessing child nodes</span></a></li><li><a class="tocitem" href="#Mutating-the-tree"><span>Mutating the tree</span></a></li><li><a class="tocitem" href="#Copying-trees"><span>Copying trees</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../astmacro/">Constructing trees</a></li><li><a class="tocitem" href="../iteration/">Iteration over trees</a></li><li><a class="tocitem" href="../stdlib/">Conversion to/from <code>Markdown</code></a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tree node interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tree node interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDocs/MarkdownAST.jl" title="View the repository on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/main/docs/src/node.md" title="Edit source on GitHub"><span class="docs-icon fas"></span></a><a class="docs-settings-button docs-navbar-link fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button docs-navbar-link fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tree-node-interface"><a class="docs-heading-anchor" href="#Tree-node-interface">Tree node interface</a><a id="Tree-node-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-node-interface" title="Permalink"></a></h1><p>The Markdown abstract syntax tree (AST) is a tree of <a href="../elements/#MarkdownAST.AbstractElement">Markdown elements</a>. In order to avoid type instabilities when performing basic operations on a tree, such as traversin it, it is implemented by linking together instances of the <a href="#MarkdownAST.Node"><code>Node</code></a> type. Each <a href="#MarkdownAST.Node"><code>Node</code></a> instance functions as a container for some <a href="../elements/#MarkdownAST.AbstractElement"><code>AbstractElement</code></a>.</p><p>The <a href="#MarkdownAST.Node"><code>Node</code></a> type has various <em>properties</em> that can be used to access information about the structure of the tree, but it is generally not possible to set them directly. Changing the structure of a tree (e.g. to adding child nodes), should be done with the help of the <a href="#Mutating-the-tree">various functions and methods to MarkdownAST provides for mutating the tree</a>.</p><article class="docstring"><header><a class="docstring-binding" id="MarkdownAST.Node" href="#MarkdownAST.Node"><code>MarkdownAST.Node</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Node{M}</code></pre><p>Implements a linked list type representation of a Markdown abstract syntax tree, where each node contains pointers to the children and parent nodes, to make it possible to easily traverse the whole tree in any direction. Each node also contains an &quot;element&quot;, which is an instance of some <a href="../elements/#MarkdownAST.AbstractElement"><code>AbstractElement</code></a> subtype, and can be accessed via the <code>.element</code> property. The element object contains the semantic information about the node (e.g. wheter it is a list or a paragraph).</p><p>Optionally, each node can also store additional meta information, which will be an object of type <code>M</code> (see also the <code>.meta</code> property). By default, the node does not contain any extra meta information and <code>M = Nothing</code>.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">Node(element :: AbstractElement)</code></pre><p>Constructs a simple standalone node (not part of any tree) without any additional metadata (<code>M = Nothing</code>) containing the Markdown AST element <code>c</code>.</p><pre><code class="language-julia hljs">Node{M}(element :: AbstractElement, meta :: M)</code></pre><p>Constructs a simple standalone node (not part of any tree) with the meta information <code>meta</code>, containing the Markdown AST element <code>c</code>.</p><p><strong>Extended help</strong></p><p>There are various properties that can be used to access the details of a node. Many of them can not be set directly though, as that could lead to an inconsistent tree. Similarly, the underlying fields of the struct should not be accessed directly.</p><ul><li><code>.meta :: M</code>: can be used to access or set the extra meta information of the node.</li><li><code>.element :: T where {T &lt;: AbstractElement}</code>: can be used to access or set the <em>element</em> corresponding to the node</li><li><code>.next :: Union{Node{M},Nothing}</code>: access the next child node after this one, with the value set to <code>nothing</code> if there is no next child</li><li><code>.previous :: Union{Node{M},Nothing}</code>: access the previous child node before this one, with the value set to <code>nothing</code> if there is no such node</li><li><code>.parent :: Union{Node{M},Nothing}</code>: access the parent node of this node, with the value set to <code>nothing</code> if the node does not have a parent</li><li><code>.children</code>: an iterable object of type <a href="#MarkdownAST.NodeChildren"><code>NodeChildren</code></a> that can be used to access and modify the child nodes of this node</li></ul><p>The <code>.children</code> field is implemented with a wrapper type that implemements the iteration protocol. However, the exact type information etc. is an implementation detail, and one should only rely on the following documented APIs:</p><ul><li>The following methods are implemented for <code>.children</code>: <a href="#Base.length-Tuple{MarkdownAST.NodeChildren}"><code>length</code></a>, <a href="#Base.eltype-Union{Tuple{Type{MarkdownAST.NodeChildren{T}}}, Tuple{T}} where T"><code>eltype</code></a>, <a href="#Base.first-Union{Tuple{MarkdownAST.NodeChildren{T}}, Tuple{T}} where T"><code>first</code></a>, <a href="#Base.last-Union{Tuple{MarkdownAST.NodeChildren{T}}, Tuple{T}} where T"><code>last</code></a>, <a href="#Base.isempty-Tuple{MarkdownAST.NodeChildren}"><code>isempty</code></a></li><li>Appending or prepending new children to a parent node can be done with the <a href="#Base.push!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, T}} where T&lt;:MarkdownAST.Node"><code>push!</code></a>, <a href="#Base.pushfirst!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, T}} where T&lt;:MarkdownAST.Node"><code>pushfirst!</code></a>, <a href="#Base.append!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, Any}} where T"><code>append!</code></a>, and <a href="#Base.prepend!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, Any}} where T"><code>prepend!</code></a> methods</li></ul><p>Other ways to work with child nodes that do not directly reference <code>.children</code> are:</p><ul><li>To add new children between others, the <a href="#MarkdownAST.insert_after!"><code>insert_after!</code></a>, <a href="#MarkdownAST.insert_before!"><code>insert_before!</code></a> functions can be used to insert new children relative to a reference child node.</li><li>To remove a child from a node, the <a href="#MarkdownAST.unlink!"><code>unlink!</code></a> function can be used on the corresponding child node.</li></ul><p>In addition, there are other functions and methods that can be used to work with nodes and trees:</p><ul><li>Querying information about the node: <a href="#MarkdownAST.haschildren"><code>haschildren</code></a></li><li>Removing a node from a tree: <a href="#MarkdownAST.unlink!"><code>unlink!</code></a></li><li>Two trees can be compared with the <a href="#Base.:==-Union{Tuple{T}, Tuple{MarkdownAST.Node{T}, MarkdownAST.Node{T}}} where T"><code>==</code> operator</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/40d3605cbdb7e470beffe91ae4b51a52a29cc9c4/src/node.jl#L4-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Union{Tuple{T}, Tuple{MarkdownAST.Node{T}, MarkdownAST.Node{T}}} where T" href="#Base.:==-Union{Tuple{T}, Tuple{MarkdownAST.Node{T}, MarkdownAST.Node{T}}} where T"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(x::Node, y::Node) -&gt; Bool</code></pre><p>Determines if two trees are equal by recursively walking through the whole tree (if need be) and comparing each node. Parent nodes are ignored when comparing for equality (so that it would be possible to compare subtrees). If the metadata type does not match, the two trees are not considered equal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/40d3605cbdb7e470beffe91ae4b51a52a29cc9c4/src/node.jl#L454-L461">source</a></section></article><h2 id="Accessing-child-nodes"><a class="docs-heading-anchor" href="#Accessing-child-nodes">Accessing child nodes</a><a id="Accessing-child-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-child-nodes" title="Permalink"></a></h2><p>Internally, to store the children, a node simply stores the reference to the first and the last child node, and each child stores the references to the next and previous child. The <code>.children</code> property is implemented simply as a lazy iterator of type <a href="#MarkdownAST.NodeChildren"><code>NodeChildren</code></a> that traverses the linked list. As such, some operations, such as determining the number of children a node has with <a href="#Base.length-Tuple{MarkdownAST.NodeChildren}"><code>length</code></a>, can have unexpected <span>$O(n)$</span> complexity.</p><article class="docstring"><header><a class="docstring-binding" id="MarkdownAST.haschildren" href="#MarkdownAST.haschildren"><code>MarkdownAST.haschildren</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">haschildren(node::Node) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>node</code> has any children nodes and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/40d3605cbdb7e470beffe91ae4b51a52a29cc9c4/src/node.jl#L157-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkdownAST.NodeChildren" href="#MarkdownAST.NodeChildren"><code>MarkdownAST.NodeChildren</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NodeChildren</code></pre><p>The type of the the <code>.children</code> property of a <a href="#MarkdownAST.Node"><code>Node</code></a> which acts as an iterator over the children of a node. This type is mostly considered to be an implementation detail, and only has the following publicly defined APIs:</p><ul><li>The name of the type <code>NodeChildren</code>, so that it could be dispatched on.</li><li>The <code>.parent :: Node</code> field that allows the user to access the parent node of the children.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/40d3605cbdb7e470beffe91ae4b51a52a29cc9c4/src/node.jl#L202-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eltype-Union{Tuple{Type{MarkdownAST.NodeChildren{T}}}, Tuple{T}} where T" href="#Base.eltype-Union{Tuple{Type{MarkdownAST.NodeChildren{T}}}, Tuple{T}} where T"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eltype(node.children::NodeChildren) = Node{M}</code></pre><p>Returns the exact <code>Node</code> type of the tree, corresponding to the type of the elements of the <code>.children</code> iterator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/40d3605cbdb7e470beffe91ae4b51a52a29cc9c4/src/node.jl#L221-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{MarkdownAST.NodeChildren}" href="#Base.length-Tuple{MarkdownAST.NodeChildren}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">length(node.children::NodeChildren) -&gt; Int</code></pre><p>Returns the number of children of <code>node :: Node</code>.</p><p>As the children are stored as a linked list, this method has O(n) complexity. As such, to check there are any children at all, it is generally preferable to use <a href="#Base.isempty-Tuple{MarkdownAST.NodeChildren}"><code>isempty</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/40d3605cbdb7e470beffe91ae4b51a52a29cc9c4/src/node.jl#L229-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isempty-Tuple{MarkdownAST.NodeChildren}" href="#Base.isempty-Tuple{MarkdownAST.NodeChildren}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isemtpy(node.children::NodeChildren) -&gt; Bool</code></pre><p>Can be called on the <code>.children</code> field of a <code>node :: Node</code> to determine whether or not the node has any child nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/40d3605cbdb7e470beffe91ae4b51a52a29cc9c4/src/node.jl#L274-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.first-Union{Tuple{MarkdownAST.NodeChildren{T}}, Tuple{T}} where T" href="#Base.first-Union{Tuple{MarkdownAST.NodeChildren{T}}, Tuple{T}} where T"><code>Base.first</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">first(node.children::NodeChildren) -&gt; Node</code></pre><p>Returns the first child of the <code>node :: Node</code>, or throws an error if the node has no children.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/40d3605cbdb7e470beffe91ae4b51a52a29cc9c4/src/node.jl#L248-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.last-Union{Tuple{MarkdownAST.NodeChildren{T}}, Tuple{T}} where T" href="#Base.last-Union{Tuple{MarkdownAST.NodeChildren{T}}, Tuple{T}} where T"><code>Base.last</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">last(node.children::NodeChildren) -&gt; Node</code></pre><p>Returns the last child of the <code>node :: Node</code>, or throws an error if the node has no children.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/40d3605cbdb7e470beffe91ae4b51a52a29cc9c4/src/node.jl#L261-L266">source</a></section></article><h2 id="Mutating-the-tree"><a class="docs-heading-anchor" href="#Mutating-the-tree">Mutating the tree</a><a id="Mutating-the-tree-1"></a><a class="docs-heading-anchor-permalink" href="#Mutating-the-tree" title="Permalink"></a></h2><p>The following functions and methods can be used to mutate the Markdown AST trees represented using <a href="#MarkdownAST.Node"><code>Node</code></a> objects. When using these methods, the consistency of the tree is preserved (i.e. the references between the affected nodes are correctly updated). Changing the structure of the tree in any other way should generally be avoided, since the code that operates on trees generally assumes a consistent tree, and will likely error or behave in unexpected ways on inconsistent trees.</p><div class="admonition is-warning"><header class="admonition-header">Mutating the tree while traversing</header><div class="admonition-body"><p>Mutating the structure of the tree while traversing it with some iterator (e.g. <code>.children</code> or one of the <a href="../iteration/#Iteration-over-trees">AbstractTrees iterators</a>) can lead to unexpected behavior and should generally be avoided. Updating the <code>.element</code> of a node, on the other hand, is fine.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="MarkdownAST.unlink!" href="#MarkdownAST.unlink!"><code>MarkdownAST.unlink!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unlink!(node::Node) -&gt; Node</code></pre><p>Isolates and removes the node from the tree by removing all of its links to its neighboring nodes. Returns the updated node, which is now a single, isolate root node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/40d3605cbdb7e470beffe91ae4b51a52a29cc9c4/src/node.jl#L164-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkdownAST.insert_before!" href="#MarkdownAST.insert_before!"><code>MarkdownAST.insert_before!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_before!(node::Node, sibling::Node) -&gt; Node</code></pre><p>Inserts a new child node <code>sibling</code> as the child right before <code>node</code>. <code>node</code> must not be a root node. If <code>sibling</code> is part of another tree, then it is unlinked from that tree first (see <a href="#MarkdownAST.unlink!"><code>unlink!</code></a>). Returns the original reference node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/40d3605cbdb7e470beffe91ae4b51a52a29cc9c4/src/node.jl#L385-L391">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkdownAST.insert_after!" href="#MarkdownAST.insert_after!"><code>MarkdownAST.insert_after!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_after!(node::Node, sibling::Node) -&gt; Node</code></pre><p>Inserts a new child node <code>sibling</code> as the next child after <code>node</code>. <code>node</code> must not be a root node. If <code>sibling</code> is part of another tree, then it is unlinked from that tree first (see <a href="#MarkdownAST.unlink!"><code>unlink!</code></a>). Returns the original reference node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/40d3605cbdb7e470beffe91ae4b51a52a29cc9c4/src/node.jl#L354-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.push!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, T}} where T&lt;:MarkdownAST.Node" href="#Base.push!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, T}} where T&lt;:MarkdownAST.Node"><code>Base.push!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.push!(node.children::NodeChildren, child::Node) -&gt; NodeChildren</code></pre><p>Adds <code>child</code> as the last child node of <code>node :: Node</code>. If <code>child</code> is part of another tree, then it is unlinked from that tree first (see <a href="#MarkdownAST.unlink!"><code>unlink!</code></a>). Returns the iterator over children.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/40d3605cbdb7e470beffe91ae4b51a52a29cc9c4/src/node.jl#L282-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pushfirst!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, T}} where T&lt;:MarkdownAST.Node" href="#Base.pushfirst!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, T}} where T&lt;:MarkdownAST.Node"><code>Base.pushfirst!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.pushfirst!(node.children::NodeChildren, child::Node) -&gt; NodeChildren</code></pre><p>Adds <code>child</code> as the first child node of <code>node :: Node</code>. If <code>child</code> is part of another tree, then it is unlinked from that tree first (see <a href="#MarkdownAST.unlink!"><code>unlink!</code></a>). Returns the iterator over children.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/40d3605cbdb7e470beffe91ae4b51a52a29cc9c4/src/node.jl#L318-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.append!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, Any}} where T" href="#Base.append!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, Any}} where T"><code>Base.append!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">append!(node.children::NodeChildren, children) -&gt; NodeChildren</code></pre><p>Adds all the elements of the iterable <code>children</code> to the end of the list of children of <code>node</code>. If any of <code>children</code> are part of another tree, then they are unlinked from that tree first (see <a href="#MarkdownAST.unlink!"><code>unlink!</code></a>). Returns the iterator over children.</p><div class="admonition is-warning"><header class="admonition-header">Error during an append</header><div class="admonition-body"><p>The operation is not atomic, and an error during an <code>append!</code> (e.g. due to an element of the wrong type in <code>children</code>) can result in a partial append of the new children, similar to how <code>append!</code> behaves with arrays (see <a href="https://github.com/JuliaLang/julia/issues/15868">JuliaLang/julia#15868</a>).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/40d3605cbdb7e470beffe91ae4b51a52a29cc9c4/src/node.jl#L406-L419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.prepend!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, Any}} where T" href="#Base.prepend!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, Any}} where T"><code>Base.prepend!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prepend!(node.children::NodeChildren, children) -&gt; NodeChildren</code></pre><p>Adds all the elements of the iterable <code>children</code> to the beginning of the list of children of <code>node</code>. If any of <code>children</code> are part of another tree, then they are unlinked from that tree first (see <a href="#MarkdownAST.unlink!"><code>unlink!</code></a>). Returns the iterator over children.</p><div class="admonition is-warning"><header class="admonition-header">Error during a prepend</header><div class="admonition-body"><p>The operation is not atomic, and an error during a <code>prepend!</code> (e.g. due to an element of the wrong type in <code>children</code>) can result in a partial prepend of the new children, similar to how <code>append!</code> behaves with arrays (see <a href="https://github.com/JuliaLang/julia/issues/15868">JuliaLang/julia#15868</a>).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/40d3605cbdb7e470beffe91ae4b51a52a29cc9c4/src/node.jl#L428-L441">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Mutating the .children property</header><div class="admonition-body"><p>The choice to apparently mutate the <code>.children</code> property when adding child nodes is purely syntactic, and in reality the operation affects the parent <a href="#MarkdownAST.Node"><code>Node</code></a> object. Internally the <code>.children</code> iterator is simply a thin wrapper around the parent node.</p></div></div><h2 id="Copying-trees"><a class="docs-heading-anchor" href="#Copying-trees">Copying trees</a><a id="Copying-trees-1"></a><a class="docs-heading-anchor-permalink" href="#Copying-trees" title="Permalink"></a></h2><p>The <a href="#MarkdownAST.copy_tree"><code>copy_tree</code></a> function can be used to easily copy a tree.</p><article class="docstring"><header><a class="docstring-binding" id="MarkdownAST.copy_tree" href="#MarkdownAST.copy_tree"><code>MarkdownAST.copy_tree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">copy_tree(root::Node)
copy_tree(f, root::Node)</code></pre><p>Creates a copy of the tree, starting from <code>node</code> as the root node, and  optionally calling <code>f</code> on each of the nodes to determine the corresponding <code>.element</code> in the copied tree.</p><p>If <code>node</code> is not the root of its tree, its parent nodes are ignored, and the root node of the copied node corresponds to <code>node</code>.</p><p>The function <code>f</code> should have the signature <code>(::Node, ::AbstractElement) -&gt; AbstractElement</code>, and it gets passed the current node being copied and its element. It must return an instance of some <a href="../elements/#MarkdownAST.AbstractElement"><code>AbstractElement</code></a>, which will then be assigned to the <code>.element</code> field of the copied node. By default, <code>copy_tree</code> performs a <code>deepcopy</code> of both the element (<code>.element</code>) and the node metadata (<code>.meta</code>).</p><p><strong>Extended help</strong></p><p>For example, to perform a <code>copy</code> instead of <code>deepcopy</code> on the elements, <code>copy_tree</code> can be called as follows</p><pre><code class="language-julia hljs">copy_tree((_, e) -&gt; copy(e), node::Node)</code></pre><p>Note that <code>copy_tree</code> does not allow the construction of invalid trees, and element replacements that require invalid parent-child relationships (e.g. a block element as a child to an element expecting inlines) will throw an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/40d3605cbdb7e470beffe91ae4b51a52a29cc9c4/src/tools.jl#L1-L29">source</a></section></article><p>This can be particularly useful in circumstances where a tree is passed to other code that while processing the tree also mutates it. As <a href="#MarkdownAST.Node"><code>Node</code></a> is a mutable type, this means that the original tree also mutates. Passing the result from <a href="#MarkdownAST.copy_tree"><code>copy_tree</code></a> can be used to avoid that issue.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#MarkdownAST.Node"><code>MarkdownAST.Node</code></a></li><li><a href="#MarkdownAST.NodeChildren"><code>MarkdownAST.NodeChildren</code></a></li><li><a href="#Base.:==-Union{Tuple{T}, Tuple{MarkdownAST.Node{T}, MarkdownAST.Node{T}}} where T"><code>Base.:==</code></a></li><li><a href="#Base.append!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, Any}} where T"><code>Base.append!</code></a></li><li><a href="#Base.eltype-Union{Tuple{Type{MarkdownAST.NodeChildren{T}}}, Tuple{T}} where T"><code>Base.eltype</code></a></li><li><a href="#Base.first-Union{Tuple{MarkdownAST.NodeChildren{T}}, Tuple{T}} where T"><code>Base.first</code></a></li><li><a href="#Base.isempty-Tuple{MarkdownAST.NodeChildren}"><code>Base.isempty</code></a></li><li><a href="#Base.last-Union{Tuple{MarkdownAST.NodeChildren{T}}, Tuple{T}} where T"><code>Base.last</code></a></li><li><a href="#Base.length-Tuple{MarkdownAST.NodeChildren}"><code>Base.length</code></a></li><li><a href="#Base.prepend!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, Any}} where T"><code>Base.prepend!</code></a></li><li><a href="#Base.push!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, T}} where T&lt;:MarkdownAST.Node"><code>Base.push!</code></a></li><li><a href="#Base.pushfirst!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, T}} where T&lt;:MarkdownAST.Node"><code>Base.pushfirst!</code></a></li><li><a href="#MarkdownAST.copy_tree"><code>MarkdownAST.copy_tree</code></a></li><li><a href="#MarkdownAST.haschildren"><code>MarkdownAST.haschildren</code></a></li><li><a href="#MarkdownAST.insert_after!"><code>MarkdownAST.insert_after!</code></a></li><li><a href="#MarkdownAST.insert_before!"><code>MarkdownAST.insert_before!</code></a></li><li><a href="#MarkdownAST.unlink!"><code>MarkdownAST.unlink!</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../elements/">« Markdown AST elements</a><a class="docs-footer-nextpage" href="../astmacro/">Constructing trees »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.28.0-DEV on <span class="colophon-date" title="Tuesday 10 January 2023 22:52">Tuesday 10 January 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
