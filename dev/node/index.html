<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tree node interface · MarkdownAST</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MarkdownAST</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../elements/">Markdown AST elements</a></li><li class="is-active"><a class="tocitem" href>Tree node interface</a><ul class="internal"><li><a class="tocitem" href="#Accessing-child-nodes"><span>Accessing child nodes</span></a></li><li><a class="tocitem" href="#Mutating-the-tree"><span>Mutating the tree</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../astmacro/">Constructing trees</a></li><li><a class="tocitem" href="../iteration/">Iteration over trees</a></li><li><a class="tocitem" href="../stdlib/">Conversion to/from <code>Markdown</code></a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tree node interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tree node interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDocs/MarkdownAST.jl" title="View the repository on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/main/docs/src/node.md" title="Edit source on GitHub"><span class="docs-icon fas"></span></a><a class="docs-settings-button docs-navbar-link fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button docs-navbar-link fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tree-node-interface"><a class="docs-heading-anchor" href="#Tree-node-interface">Tree node interface</a><a id="Tree-node-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-node-interface" title="Permalink"></a></h1><p>The Markdown abstract syntax tree (AST) is a tree of <a href="../elements/#MarkdownAST.AbstractElement">Markdown elements</a>. In order to avoid type instabilities when performing basic operations on a tree, such as traversin it, it is implemented by linking together instances of the <a href="#MarkdownAST.Node"><code>Node</code></a> type. Each <a href="#MarkdownAST.Node"><code>Node</code></a> instance functions as a container for some <a href="../elements/#MarkdownAST.AbstractElement"><code>AbstractElement</code></a>.</p><p>The <a href="#MarkdownAST.Node"><code>Node</code></a> type has various <em>properties</em> that can be used to access information about the structure of the tree, but it is generally not possible to set them directly. Changing the structure of a tree (e.g. to adding child nodes), should be done with the help of the <a href="#Mutating-the-tree">various functions and methods to MarkdownAST provides for mutating the tree</a>.</p><article class="docstring"><header><a class="docstring-binding" id="MarkdownAST.Node" href="#MarkdownAST.Node"><code>MarkdownAST.Node</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Node{M}</code></pre><p>Implements a linked list type representation of a Markdown abstract syntax tree, where each node contains pointers to the children and parent nodes, to make it possible to easily traverse the whole tree in any direction. Each node also contains an &quot;element&quot;, which is an instance of some <a href="../elements/#MarkdownAST.AbstractElement"><code>AbstractElement</code></a> subtype, and can be accessed via the <code>.element</code> property. The element object contains the semantic information about the node (e.g. wheter it is a list or a paragraph).</p><p>Optionally, each node can also store additional meta information, which will be an object of type <code>M</code> (see also the <code>.meta</code> property). By default, the node does not contain any extra meta information and <code>M = Nothing</code>.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">Node(element :: AbstractElement)</code></pre><p>Constructs a simple standalone node (not part of any tree) without any additional metadata (<code>M = Nothing</code>) containing the Markdown AST element <code>c</code>.</p><pre><code class="language-julia hljs">Node{M}(element :: AbstractElement, meta :: M)</code></pre><p>Constructs a simple standalone node (not part of any tree) with the meta information <code>meta</code>, containing the Markdown AST element <code>c</code>.</p><p><strong>Extended help</strong></p><p>There are various properties that can be used to access the details of a node. Many of them can not be set directly though, as that could lead to an inconsistent tree. Similarly, the underlying fields of the struct should not be accessed directly.</p><ul><li><code>.meta :: M</code>: can be used to access or set the extra meta information of the node.</li><li><code>.element :: T where {T &lt;: AbstractElement}</code>: can be used to access or set the <em>element</em> corresponding to the node</li><li><code>.next :: Union{Node{M},Nothing}</code>: access the next child node after this one, with the value set to <code>nothing</code> if there is no next child</li><li><code>.previous :: Union{Node{M},Nothing}</code>: access the previous child node before this one, with the value set to <code>nothing</code> if there is no such node</li><li><code>.parent :: Union{Node{M},Nothing}</code>: access the parent node of this node, with the value set to <code>nothing</code> if the node does not have a parent</li><li><code>.children</code>: an iterable object that can be used to acces and modify the children of the node</li></ul><p>The <code>.children</code> field is implemented with a wrapper type that implemements the iteration protocol. However, the exact type information etc. is an implementation detail, and one should only rely on the following documented APIs:</p><ul><li>The following methods are implemented for <code>.children</code>: <a href="#Base.length-Tuple{MarkdownAST.NodeChildren}"><code>length</code></a>, <a href="#Base.eltype-Union{Tuple{Type{MarkdownAST.NodeChildren{T}}}, Tuple{T}} where T"><code>eltype</code></a>, <a href="#Base.first-Union{Tuple{MarkdownAST.NodeChildren{T}}, Tuple{T}} where T"><code>first</code></a>, <a href="#Base.last-Union{Tuple{MarkdownAST.NodeChildren{T}}, Tuple{T}} where T"><code>last</code></a>, <a href="#Base.isempty-Tuple{MarkdownAST.NodeChildren}"><code>isempty</code></a></li><li>Appending or prepending new children to a parent node can be done with the <a href="#Base.push!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, T}} where T&lt;:MarkdownAST.Node"><code>push!</code></a> and <a href="#Base.pushfirst!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, T}} where T&lt;:MarkdownAST.Node"><code>pushfirst!</code></a> methods</li></ul><p>Other ways to work with child nodes that do not directly reference <code>.children</code> are:</p><ul><li>To add new children between others, the <a href="#MarkdownAST.insert_after!"><code>insert_after!</code></a>, <a href="#MarkdownAST.insert_before!"><code>insert_before!</code></a> functions can be used to insert new children relative to a reference child node.</li><li>To remove a child from a node, the <a href="#MarkdownAST.unlink!"><code>unlink!</code></a> function can be used on the corresponding child node.</li></ul><p>In addition, there are other functions and methods that can be used to work with nodes and trees:</p><ul><li>Querying information about the node: <a href="#MarkdownAST.haschildren"><code>haschildren</code></a></li><li>Removing a node from a tree: <a href="#MarkdownAST.unlink!"><code>unlink!</code></a></li><li>Two trees can be compared with the <a href="#Base.:==-Union{Tuple{T}, Tuple{MarkdownAST.Node{T}, MarkdownAST.Node{T}}} where T"><code>==</code> operator</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/b4585494eca5fc995a8d89cebfb3e7e65157977a/src/node.jl#L4-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Union{Tuple{T}, Tuple{MarkdownAST.Node{T}, MarkdownAST.Node{T}}} where T" href="#Base.:==-Union{Tuple{T}, Tuple{MarkdownAST.Node{T}, MarkdownAST.Node{T}}} where T"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(x::Node, y::Node) -&gt; Bool</code></pre><p>Determines if two trees are equal by recursively walking through the whole tree (if need be) and comparing each node. Parent nodes are ignored when comparing for equality (so that it would be possible to compare subtrees). If the metadata type does not match, the two trees are not considered equal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/b4585494eca5fc995a8d89cebfb3e7e65157977a/src/node.jl#L385-L392">source</a></section></article><h2 id="Accessing-child-nodes"><a class="docs-heading-anchor" href="#Accessing-child-nodes">Accessing child nodes</a><a id="Accessing-child-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-child-nodes" title="Permalink"></a></h2><p>Internally, to store the children, a node simply stores the reference to the first and the last child node, and each child stores the references to the next and previous child. The <code>.children</code> property is implemented simply as a lazy iterator that traverses the linked list. As such, some operations, such as determining the number of children a node has with <a href="#Base.length-Tuple{MarkdownAST.NodeChildren}"><code>length</code></a>, can have unexpected <span>$O(n)$</span> complexity.</p><article class="docstring"><header><a class="docstring-binding" id="MarkdownAST.haschildren" href="#MarkdownAST.haschildren"><code>MarkdownAST.haschildren</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">haschildren(node::Node) -&gt; Bool</code></pre><p>Returns <code>true</code> if <code>node</code> has any children nodes and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/b4585494eca5fc995a8d89cebfb3e7e65157977a/src/node.jl#L155-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eltype-Union{Tuple{Type{MarkdownAST.NodeChildren{T}}}, Tuple{T}} where T" href="#Base.eltype-Union{Tuple{Type{MarkdownAST.NodeChildren{T}}}, Tuple{T}} where T"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eltype(node.children) = Node{M}</code></pre><p>Returns the exact <code>Node</code> type of the tree, corresponding to the type of the elements of the <code>.children</code> iterator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/b4585494eca5fc995a8d89cebfb3e7e65157977a/src/node.jl#L210-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{MarkdownAST.NodeChildren}" href="#Base.length-Tuple{MarkdownAST.NodeChildren}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">length(node.children) -&gt; Int</code></pre><p>Returns the number of children of <code>node :: Node</code>.</p><p>As the children are stored as a linked list, this method has O(n) complexity. As such, to check there are any children at all, it is generally preferable to use <a href="#Base.isempty-Tuple{MarkdownAST.NodeChildren}"><code>isempty</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/b4585494eca5fc995a8d89cebfb3e7e65157977a/src/node.jl#L218-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isempty-Tuple{MarkdownAST.NodeChildren}" href="#Base.isempty-Tuple{MarkdownAST.NodeChildren}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isemtpy(node.children) -&gt; Bool</code></pre><p>Can be called on the <code>.children</code> field of a <code>node :: Node</code> to determine whether or not the node has any child nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/b4585494eca5fc995a8d89cebfb3e7e65157977a/src/node.jl#L263-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.first-Union{Tuple{MarkdownAST.NodeChildren{T}}, Tuple{T}} where T" href="#Base.first-Union{Tuple{MarkdownAST.NodeChildren{T}}, Tuple{T}} where T"><code>Base.first</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">first(node.children) -&gt; Node</code></pre><p>Returns the first child of the <code>node :: Node</code>, or throws an error if the node has no children.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/b4585494eca5fc995a8d89cebfb3e7e65157977a/src/node.jl#L237-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.last-Union{Tuple{MarkdownAST.NodeChildren{T}}, Tuple{T}} where T" href="#Base.last-Union{Tuple{MarkdownAST.NodeChildren{T}}, Tuple{T}} where T"><code>Base.last</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">last(node.children) -&gt; Node</code></pre><p>Returns the last child of the <code>node :: Node</code>, or throws an error if the node has no children.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/b4585494eca5fc995a8d89cebfb3e7e65157977a/src/node.jl#L250-L255">source</a></section></article><h2 id="Mutating-the-tree"><a class="docs-heading-anchor" href="#Mutating-the-tree">Mutating the tree</a><a id="Mutating-the-tree-1"></a><a class="docs-heading-anchor-permalink" href="#Mutating-the-tree" title="Permalink"></a></h2><p>The following functions and methods can be used to mutate the Markdown AST trees represented using <a href="#MarkdownAST.Node"><code>Node</code></a> objects. When using these methods, the consistency of the tree is preserved (i.e. the references between the affected nodes are correctly updated). Changing the structure of the tree in any other way should generally be avoided, since the code that operates on trees generally assumes a consistent tree, and will likely error or behave in unexpected ways on inconsistent trees.</p><div class="admonition is-warning"><header class="admonition-header">Mutating the tree while traversing</header><div class="admonition-body"><p>Mutating the structure of the tree while traversing it with some iterator (e.g. <code>.children</code> or one of the <a href="../iteration/#Iteration-over-trees">AbstractTrees iterators</a>) can lead to unexpected behavior and should generally be avoided. Updating the <code>.element</code> of a node, on the other hand, is fine.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="MarkdownAST.unlink!" href="#MarkdownAST.unlink!"><code>MarkdownAST.unlink!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unlink!(node::Node) -&gt; Node</code></pre><p>Isolates and removes the node from the tree by removing all of its links to its neighboring nodes. Returns the updated node, which is now a single, isolate root node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/b4585494eca5fc995a8d89cebfb3e7e65157977a/src/node.jl#L162-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkdownAST.insert_before!" href="#MarkdownAST.insert_before!"><code>MarkdownAST.insert_before!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_before!(node::Node, sibling::Node) -&gt; Node</code></pre><p>Inserts a new child node <code>sibling</code> as the child right before <code>node</code>. <code>node</code> must not be a root node. If <code>sibling</code> is part of another tree, then it is unlinked from that tree first (see <a href="#MarkdownAST.unlink!"><code>unlink!</code></a>). Returns the original reference node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/b4585494eca5fc995a8d89cebfb3e7e65157977a/src/node.jl#L360-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MarkdownAST.insert_after!" href="#MarkdownAST.insert_after!"><code>MarkdownAST.insert_after!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">insert_after!(node::Node, sibling::Node) -&gt; Node</code></pre><p>Inserts a new child node <code>sibling</code> as the next child after <code>node</code>. <code>node</code> must not be a root node. If <code>sibling</code> is part of another tree, then it is unlinked from that tree first (see <a href="#MarkdownAST.unlink!"><code>unlink!</code></a>). Returns the original reference node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/b4585494eca5fc995a8d89cebfb3e7e65157977a/src/node.jl#L329-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.push!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, T}} where T&lt;:MarkdownAST.Node" href="#Base.push!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, T}} where T&lt;:MarkdownAST.Node"><code>Base.push!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.push!(node.children, child::Node) -&gt; Node</code></pre><p>Adds <code>child</code> as the last child node of <code>node :: Node</code>. If <code>child</code> is part of another tree, then it is unlinked from that tree first (see <a href="#MarkdownAST.unlink!"><code>unlink!</code></a>). Returns the iterator over children.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/b4585494eca5fc995a8d89cebfb3e7e65157977a/src/node.jl#L271-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pushfirst!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, T}} where T&lt;:MarkdownAST.Node" href="#Base.pushfirst!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, T}} where T&lt;:MarkdownAST.Node"><code>Base.pushfirst!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.pushfirst!(node.children, child::Node) -&gt; Node</code></pre><p>Adds <code>child</code> as the first child node of <code>node :: Node</code>. If <code>child</code> is part of another tree, then it is unlinked from that tree first (see <a href="#MarkdownAST.unlink!"><code>unlink!</code></a>). Returns the iterator over children.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDocs/MarkdownAST.jl/blob/b4585494eca5fc995a8d89cebfb3e7e65157977a/src/node.jl#L300-L306">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Mutating the .children property</header><div class="admonition-body"><p>The choice to apparently mutate the <code>.children</code> property when adding child nodes is purely syntactic, and in reality the operation affects the parent <a href="#MarkdownAST.Node"><code>Node</code></a> object. Internally the <code>.children</code> iterator is simply a thin wrapper around the parent node.</p></div></div><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#MarkdownAST.Node"><code>MarkdownAST.Node</code></a></li><li><a href="#Base.:==-Union{Tuple{T}, Tuple{MarkdownAST.Node{T}, MarkdownAST.Node{T}}} where T"><code>Base.:==</code></a></li><li><a href="#Base.eltype-Union{Tuple{Type{MarkdownAST.NodeChildren{T}}}, Tuple{T}} where T"><code>Base.eltype</code></a></li><li><a href="#Base.first-Union{Tuple{MarkdownAST.NodeChildren{T}}, Tuple{T}} where T"><code>Base.first</code></a></li><li><a href="#Base.isempty-Tuple{MarkdownAST.NodeChildren}"><code>Base.isempty</code></a></li><li><a href="#Base.last-Union{Tuple{MarkdownAST.NodeChildren{T}}, Tuple{T}} where T"><code>Base.last</code></a></li><li><a href="#Base.length-Tuple{MarkdownAST.NodeChildren}"><code>Base.length</code></a></li><li><a href="#Base.push!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, T}} where T&lt;:MarkdownAST.Node"><code>Base.push!</code></a></li><li><a href="#Base.pushfirst!-Union{Tuple{T}, Tuple{MarkdownAST.NodeChildren{T}, T}} where T&lt;:MarkdownAST.Node"><code>Base.pushfirst!</code></a></li><li><a href="#MarkdownAST.haschildren"><code>MarkdownAST.haschildren</code></a></li><li><a href="#MarkdownAST.insert_after!"><code>MarkdownAST.insert_after!</code></a></li><li><a href="#MarkdownAST.insert_before!"><code>MarkdownAST.insert_before!</code></a></li><li><a href="#MarkdownAST.unlink!"><code>MarkdownAST.unlink!</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../elements/">« Markdown AST elements</a><a class="docs-footer-nextpage" href="../astmacro/">Constructing trees »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.28.0-DEV on <span class="colophon-date" title="Sunday 14 August 2022 07:16">Sunday 14 August 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
